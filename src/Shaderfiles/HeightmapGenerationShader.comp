#version 430 core

layout (local_size_x = 25, local_size_y = 25) in;
layout (binding = 0, r32f) uniform image2D img_output;
//layout (binding = 0, rgba32f) uniform image2D img_output;

uniform float size;
uniform float density;
uniform float frequency;
uniform float amplitude;

vec2 hash21(vec2 p)
{
    float h = dot(p, vec2(127.1, 311.7));

    return -1.0 + 2.0 * fract(sin(h) * 43758.5453123);
}

float ValueNoise(vec2 p)
{
    vec2 pi = floor(p);
    vec2 pf = fract(p);
     
    vec2 w = pf * pf * pf * (6 * pf * pf - 15 * pf + 10);
     
    return mix(mix(hash21(pi + vec2(0.0, 0.0)),hash21(pi + vec2(1.0, 0.0)), w.x),
                mix(hash21(pi + vec2(0.0, 1.0)), hash21(pi + vec2(1.0, 1.0)), w.x),w.y);
}

vec2 hash22(vec2 p)
{
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));

    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float Perlin(in vec2 p)
{
    vec2 pi = floor(p);     //Return the largest integer less than or equal to x.
    vec2 pf = fract(p);     //Returns the decimal part of the input value.
    
    //float2 w = pf * pf * (3.0 - 2.0 * pf);
    vec2 w = pf * pf * pf * (6 * pf * pf - 15 * pf + 10);
     
    return mix(mix(dot(hash22(pi + vec2(0.0, 0.0)), pf - vec2(0.0, 0.0)),
                    dot(hash22(pi + vec2(1.0, 0.0)), pf - vec2(1, 0.0)), w.x),
                mix(dot(hash22(pi + vec2(0.0, 1.0)), pf - vec2(0.0, 1.0)),
                    dot(hash22(pi + vec2(1.0, 1.0)), pf - vec2(1.0, 1.0)), w.x), w.y);
}

float SimplexNoise( in vec2 p )
{
    const float K1 = 0.366025404; // (sqrt(3)-1)/2;
    const float K2 = 0.211324865; // (3-sqrt(3))/6;

	vec2  i = floor( p + (p.x+p.y)*K1 );
    vec2  a = p - i + (i.x+i.y)*K2;
    float m = step(a.y,a.x); 
    vec2  o = vec2(m,1.0-m);
    vec2  b = a - o + K2;
	vec2  c = a - 1.0 + 2.0*K2;
    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );
	vec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));
    return dot( n, vec3(70.0) );
}

//Calculate the squared length of a vector
float length2(vec2 p){
    return dot(p,p);
}

//Generate some noise to scatter points.
float noise(vec2 p){
	return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);
}

float worley(vec2 p) {
    //Set our distance to infinity
	float d = 1e30;

    //For the 9 surrounding grid points
	for (int xo = -1; xo <= 1; ++xo) {
		for (int yo = -1; yo <= 1; ++yo) {
            //Floor our vec2 and add an offset to create our point
			vec2 tp = floor(p) + vec2(xo, yo);
            //Calculate the minimum distance for this grid point
            //Mix in the noise value too!
			d = min(d, length2(p - tp - noise(tp)));
		}
	}

	return 3.0*exp(-4.0*abs(2.5*d - 1.0));
}

float fworley(vec2 p) {
    //Stack noise layers 
	return sqrt(sqrt(sqrt(
		worley(p*5.0 + 0.05) *
		sqrt(worley(p * 50.0 + 0.12 + -0.1)) *
		sqrt(sqrt(worley(p * -10.0 + 0.03))))));
}

// Calculate height for given position
vec4 calculateHeight(vec2 p){
    float f = 0.0;
    mat2 m = mat2(1.6, 1.2, -1.2, 1.6);

    f  = 0.4000 * SimplexNoise(p); p = m * p;
    f += 0.3000 * SimplexNoise(p); p = m * p;
    f += 0.1000 * SimplexNoise(p); p = m * p;
    f += 0.0500 * SimplexNoise(p); p = m * p;
    f += 0.0250 * SimplexNoise(p); p = m * p;
    f += 0.0125 * SimplexNoise(p); p = m * p;
    f += 0.0062 * SimplexNoise(p); p = m * p;
    f += 0.0031 * SimplexNoise(p); p = m * p;

    f = amplitude * 0.5 + amplitude * 0.5 * f;

    return vec4(f, 0, 0, 1.0);
}


void main()
{
    // Get index in global work group i.e x,y position
    ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);
    vec2 p = pixelCoords * size / density * (1 / frequency);

    // Output to a specific pixel in the image
    imageStore(img_output, pixelCoords, calculateHeight(p));
    // imageStore(img_output, pixelCoords, vec4(0, 0, 0, 1.0));
    

    //** Random trash which migh turn out helpful **//

    // f += Perlin(p);
    // f += -worley(p);

    // f *= smoothstep(0.0, 0.005, abs(p.x-0.6));
	
    // output to a specific pixel in the image
	// imageStore(img_output, pixel_coords, vec4(f, 0, 0, 1.0));

    // if( gl_GlobalInvocationID.x < 100 && gl_GlobalInvocationID.y < 100){
    //     imageStore(img_output, pixel_coords, vec4(1, 0, 0, 1.0));
    // }
    // 
    // if( gl_GlobalInvocationID.x > density* 0.4 && gl_GlobalInvocationID.x < density * 0.6 ){
    //     imageStore(img_output, pixel_coords, vec4(0, 0, 0, 1.0));
    // }
    // 
    // if( gl_GlobalInvocationID.y > density* 0.4 && gl_GlobalInvocationID.y < density * 0.6 ){
    //     imageStore(img_output, pixel_coords, vec4(0, 0, 0, 1.0));
    // }
}